use std::str::FromStr;
use crate::ast::{Op};

grammar;

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None=> v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};



Pipe<T>: Vec<T> = {
    <v:(<T> "|")+> <e:T?> => match e {
        None=> v,
        Some(e) => {
          let mut v = v;
          v.push(e);
          v
        }
    }
};

Compose = Pipe<Operation>;

Operations = Comma<Operation>;

pub Operation: Op = {
    <ops: Pipe<BaseOperation>> => Op::Compose { operations: ops },
    <o: BaseOperation> => o
}

<let: Let> => table.add(let)


pub BaseOperation: Op = {
    "AsIs" => Op::AsIs,
    "Reverse" => Op::Reverse,
    "Silence" <v:Value> => Op::Silence {m: v},
    "Tm" <v:Value> => Op::TransposeM {m: v},
    "Ta" <v:Value> => Op::TransposeA {a: v},
    "PanM" <v:Value> => Op::PanM {m: v},
    "PanA" <v:Value> => Op::PanA {a: v},
    "Length" <v:Value> => Op::Length {m: v},
    "Gain" <v:Value> => Op::Gain {m: v},
    "Sequence" "[" <operations: Operations> "]" => Op::Sequence { operations: operations },
    "Overlay" "[" <operations: Operations> "]" => Op::Overlay { operations: operations },
    "o" "[" <o: Overtones> "]" => Op::Overlay { operations: o },
    <id: Identifier> => { table.find(id).clone() }
    "(" <o: Operation> ")" => o
};

Overtone: Op = {
    "("
        <v:Value> ","
        <o:Value> ","
        <g:Value> ","
        <p:Value>
    ")"
    => Op::Compose { operations: vec! [
            Op::TransposeM { m: v },
            Op::TransposeA { a: o },
            Op::Gain { m: g },
            Op::PanA { a: p },
        ]
    }
}

Overtones = Comma<Overtone>;

Value: f32 = {
    <n:Num> => n,
    <n:Num> "/" <d:Num> => n/d

};

Num: f32 = <s:r"-?(0|([1-9]\d*))(\.\d+)?+"> => f32::from_str(s).unwrap();
